var documenterSearchIndex = {"docs":
[{"location":"#Normalize.jl","page":"Contents","title":"Normalize.jl","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"Normalize.jl is a small package that can consume nested data structures like dictionaries of dictionaries or structs of structs and produce a normalized, Tables.jl-compliant NamedTuple. It can be used with JSON3.jl, XMLDict.jl, and other packages that parse file formats which are structured as denormalized data.","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Depth = 4","category":"page"},{"location":"#Getting-Started","page":"Contents","title":"Getting Started","text":"","category":"section"},{"location":"#Install","page":"Contents","title":"Install","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"using Pkg\nPkg.add(url=\"https://github.com/mrufsvold/Normalize.jl\")","category":"page"},{"location":"#Basic-Usage","page":"Contents","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"Normalize provides a single function normalize to flatten out nested data. ","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"using Normalize #hide\nusing JSON3\nusing DataFrames\n\nmessage = JSON3.read(\"\"\"\n    {\n        \"a\" : [\n            {\"b\" : 1, \"c\" : 2},\n            {\"b\" : 2},\n            {\"b\" : [3, 4], \"c\" : 1},\n            {\"b\" : []}\n        ],\n        \"d\" : 4\n    }\n    \"\"\"\n)\n\nnormalize(message) |> DataFrame","category":"page"},{"location":"#Configuring-Options","page":"Contents","title":"Configuring Options","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"While normalize can produce a Table out of the box, it is often useful to configure some options in how it handles the normalization process. Normalize.jl offers two ways to set these configurations. You can set them globally with kwargs or exercise finer control with per-column configurations.","category":"page"},{"location":"#Keyword-Arguments","page":"Contents","title":"Keyword Arguments","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"Parameter Description\nflatten_arrays::Bool When a leaf node is an array, should the values be flattened into separate rows or treated as a single value. Default: true\ndefault_value::Any When a certain key exists in one branch, but not another, what value should be used to fill missing. Default: missing\npool_arrays::Bool When collecting vectors for columns, choose whether to use PooledArrays instead of Base.Vector\ncolumn_names::Dict{Vector{Symbol}, Symbol} Provide a mapping of key/fieldname paths to replaced column names","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"using Normalize #hide\nusing JSON3 #hide\nusing DataFrames #hide\n\nmessage = JSON3.read(\"\"\" \n    { \n        \"a\" : [ \n            {\"b\" : 1, \"c\" : 2}, \n            {\"b\" : 2}, \n            {\"b\" : [3, 4], \"c\" : 1}, \n            {\"b\" : []} \n        ], \n        \"d\" : 4 \n    } \n    \"\"\" \n) \n\nname_map = Dict([:a, :b] => :Column_B)\n\nnormalize(message; flatten_arrays=true, default_value=\"no value\", pool_arrays=true, column_names=name_map) |> DataFrame","category":"page"},{"location":"#Using-ColumnDefintions","page":"Contents","title":"Using ColumnDefintions","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"Instead of setting the configurations for the whole dataset, you can use a Vector{ColumnDefinition} to control how each column is handled. ColumnDefinition has the added benefit of allowing you to ignore certain fields from the input.","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"using Normalize #hide\nusing JSON3 #hide\nusing DataFrames #hide\n\nmessage = JSON3.read(\"\"\" \n    { \n        \"a\" : [ \n            {\"b\" : 1, \"c\" : 2}, \n            {\"b\" : 2}, \n            {\"b\" : [3, 4], \"c\" : 1}, \n            {\"b\" : []} \n        ], \n        \"d\" : 4 \n    } \n    \"\"\" \n) \ncolumn_defs = [\n    ColumnDefinition([:d]; column_name = :ColumnD),\n    ColumnDefinition([:a, :b]; flatten_arrays=true),\n    ColumnDefinition([:e, :f]; column_name = :MissingColumn, default_value=\"Missing branch\")\n]\n\nnormalize(message, column_defs) |> DataFrame","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"The only difference in the kwargs API here is that column_names is column_name and accepts a single Symbol.","category":"page"},{"location":"#API","page":"Contents","title":"API","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"Normalize.normalize(::Any)\nNormalize.normalize(::Any, ::Vector{Normalize.ColumnDefinition})\nNormalize.ColumnDefinition","category":"page"},{"location":"#Normalize.normalize-Tuple{Any}","page":"Contents","title":"Normalize.normalize","text":"normalize(data; flatten_arrays = false, default_value = missing, pool_arrays = false, column_names=Dict{Vector{Symbol}, Symbol}())\n\nTake a nested data structure, data and convert it into a Table\n\nArgs\n\ndata: Any nested data structure (struct of structs or Dict of Dicts) or an array of such data structures\n\nKeyword Args\n\nflatten_arrays: When a leaf node is an array, should the values be flattened into separate rows or treated as a single value. Default: true\ndefault_value: When a certain key exists in one branch, but not another, what value should be used to fill missing. Default: missing\npool_arrays: When collecting vectors for columns, choose whether to use PooledArrays instead of Base.Vector. Default: false (use Vector)\ncolumn_names::Dict{Vector{Symbol}, Symbol}: Provide a mapping of key/fieldname paths to replaced column names\n\nReturns\n\n::NamedTuple: A Tables.jl compliant Tuple of Vectors\n\n\n\n\n\n","category":"method"},{"location":"#Normalize.normalize-Tuple{Any, Vector{ColumnDefinition}}","page":"Contents","title":"Normalize.normalize","text":"normalize(data, column_defs::Vector{ColumnDefinition})\n\nTake a nested data structure, data and convert it into a Table based on configurations passed for each column.\n\nArgs\n\ndata: Any nested data structure (struct of structs or Dict of Dicts) or an array of such data structures\ncolumn_defs::Vector{ColumnDefinition}: A ColumnDefinition for each column to be extracted from the data\n\nReturns\n\n::NamedTuple: A Tables.jl compliant Tuple of Vectors\n\n\n\n\n\n","category":"method"},{"location":"#Normalize.ColumnDefinition","page":"Contents","title":"Normalize.ColumnDefinition","text":"ColumnDefinition(field_path; column_name=nothing, flatten_arrays=false, default_value=missing, pool_arrays=false)\n\nArgs\n\nfield_path: Vector of keys/fieldnames that constitute a path from the top of the data to the values to extract for the column\n\nKeyword Args\n\ncolumn_name::Symbol: A name for the resulting column. If nothing, defaults to joining the fieldpath with snakecase_format.\nflatten_arrays: When a leaf node is an array, should the values be flattened into separate rows or treated as a single value. Default: true\ndefault_value: When the field_path keys do not exist on one or more branches, fill with this value. Default: missing\npool_arrays: When collecting values for this column, choose whether to use PooledArrays instead of Base.Vector. Default: false (use Vector)\n\nReturns\n\n::ColumnDefinition\n\n\n\n\n\n","category":"type"}]
}
