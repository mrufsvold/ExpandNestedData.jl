var documenterSearchIndex = {"docs":
[{"location":"#ExpandNestedData.jl","page":"Home","title":"ExpandNestedData.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExpandNestedData.jl is a small package that can consume nested data structures like dictionaries of dictionaries or structs of structs and produce a normalized, Tables.jl-compliant NamedTuple. It can be used with JSON3.jl, XMLDict.jl, and other packages that parse file formats which are structured as denormalized data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depth = 4","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ExpandNestedData\")","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExpandNestedData provides a single function expand to flatten out nested data. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExpandNestedData #hide\nusing JSON3\nusing DataFrames\n\nmessage = JSON3.read(\"\"\"\n    {\n        \"a\" : [\n            {\"b\" : 1, \"c\" : 2},\n            {\"b\" : 2},\n            {\"b\" : [3, 4], \"c\" : 1},\n            {\"b\" : []}\n        ],\n        \"d\" : 4\n    }\n    \"\"\"\n)\n\nexpand(message) |> DataFrame","category":"page"},{"location":"#Configuring-Options","page":"Home","title":"Configuring Options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While expand can produce a Table out-of-the-box, it is often useful to configure some options in how it handles the normalization process. ExpandNestedData.jl offers two ways to set these configurations. You can set them at the table-level with kwargs to expand or exercise finer control with per-column configurations.","category":"page"},{"location":"#Keyword-Arguments","page":"Home","title":"Keyword Arguments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Parameter Description\ndefault_value::Any When a certain key exists in one branch, but not another, what value should be used to fill missing. Default: missing\nlazy_columns::Bool If true, return columns as a custom lazy iterator instead of collecting them as materialized vectors. This option can speed things up if you only need to access a subset of rows once. It is usually better to materialize the columns since getindex() on the lazy columns is expensive. Default: false\npool_arrays::Bool When collecting vectors for columns, choose whether to use PooledArrays instead of Base.Vector\ncolumn_names::Dict{Tuple, Symbol} Provide a mapping of key/fieldname paths to replaced column names\ncolumn_style::Symbol Choose returned column style from :nested or :flat. If nested, column_names are ignored and a TypedTables.Table is returned in which the columns are nested in the same structure as the source data. Default: :flat\nname_join_pattern::String A pattern to put between the keys when joining the path into a column name. Default: \"_\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExpandNestedData #hide\nusing JSON3 #hide\nusing DataFrames #hide\n\nmessage = Dict( :a => [ Dict(:b => 1, :c => 2), Dict(:b => 2), Dict(:b => [3, 4], :c => 1), Dict(:b => []) ], :d => 4) #hide\n\nname_map = Dict([:a, :b] => :Column_B)\nexpand(message; default_value=\"no value\", pool_arrays=true, column_names=name_map) |> DataFrame","category":"page"},{"location":"#Using-ColumnDefintions","page":"Home","title":"Using ColumnDefintions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Instead of setting the configurations for the whole dataset, you can use a Vector{ColumnDefinition} to control how each column is handled. ColumnDefinition has the added benefit of allowing you to ignore certain fields from the input.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExpandNestedData #hide\nusing JSON3 #hide\nusing DataFrames #hide\n\nmessage = Dict( :a => [ Dict(:b => 1, :c => 2), Dict(:b => 2), Dict(:b => [3, 4], :c => 1), Dict(:b => []) ], :d => 4) #hide\n\ncolumn_defs = [\n    ColumnDefinition([:d]; column_name = :ColumnD),\n    ColumnDefinition([:a, :b]),\n    ColumnDefinition([:e, :f]; column_name = :MissingColumn, default_value=\"Missing branch\")\n]\n\nexpand(message, column_defs) |> DataFrame","category":"page"},{"location":"","page":"Home","title":"Home","text":"The only difference in the kwargs API here is that column_names is column_name and accepts a single Symbol.","category":"page"},{"location":"#ColumnStyles","page":"Home","title":"ColumnStyles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the examples above, we've used flat_columns style. However, we can also maintain the nesting hierarchy of the source data. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExpandNestedData #hide\nusing JSON3 #hide\nmessage = Dict( :a => [ Dict(:b => 1, :c => 2), Dict(:b => 2), Dict(:b => [3, 4], :c => 1), Dict(:b => []) ], :d => 4) #hide\nusing TypedTables\n\ntbl = expand(message; column_style = nested_columns)\ntbl.a.b[1] == 1 # true\n# `rows(tbl)` returns a nested NamedTuple \ntbl |> rows |> first","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExpandNestedData.expand(::Any, ::Vector{ExpandNestedData.ColumnDefinition})\nExpandNestedData.ColumnDefinition(::Any;)","category":"page"},{"location":"#ExpandNestedData.expand-Tuple{Any, Vector{ColumnDefinition}}","page":"Home","title":"ExpandNestedData.expand","text":"expand(data, column_defs=nothing; \n        default_value = missing, \n        lazy_columns::Bool = false,\n        pool_arrays::Bool = false, \n        column_names::Dict = Dict{Tuple, Symbol}(),\n        column_style::Symbol=:flat, \n        name_join_pattern = \"_\")\n\nExpand a nested data structure into a Tables\n\nArgs:\n\ndata::Any - The nested data to unpack\ncolumn_defs::Vector{ColumnDefinition} - A list of paths to follow in data, ignoring other branches. Optional. Default: nothing.\n\nKwargs:\n\nlazy_columns::Bool - If true, return columns using a lazy iterator. If false, collect into regular vectors before returning. Default: true (don't collect).\npool_arrays::Bool - If true, use pool arrays to collect the columns. Default: false.\ncolumn_names::Dict{Tuple, Symbol} - A lookup to replace column names in the final result with any other symbol\ncolumn_style::Symbol - Choose returned column style from :nested or :flat. If nested, column_names are ignored    and a TypedTables.Table is returned in which the columns are nested in the same structure as the source data. Default: :flat\nname_join_pattern::String - A pattern to put between the keys when joining the path into a column name. Default: \"_\".\n\nReturns\n\n::NamedTuple\n\n\n\n\n\n","category":"method"},{"location":"#ExpandNestedData.ColumnDefinition-Tuple{Any}","page":"Home","title":"ExpandNestedData.ColumnDefinition","text":"ColumnDefinition(field_path; column_name=nothing, flatten_arrays=false, default_value=missing, pool_arrays=false)\n\nArgs\n\nfield_path: Vector or Tuple of keys/fieldnames that constitute a path from the top of the data to the values to extract for the column\n\nKeyword Args\n\ncolumn_name::Symbol: A name for the resulting column. If nothing, defaults to joining the field_path with snake case format.\nflatten_arrays::Bool: When a leaf node is an array, should the values be flattened into separate rows or treated as a single value. Default: true\ndefault_value: When the field_path keys do not exist on one or more branches, fill with this value. Default: missing\npool_arrays::Bool: When collecting values for this column, choose whether to use PooledArrays instead of Base.Vector. Default: false (use Vector)\nname_join_pattern::String: The separator for joining field paths into column names. Default: \"_\"\n\nReturns\n\n::ColumnDefinition\n\n\n\n\n\n","category":"method"}]
}
