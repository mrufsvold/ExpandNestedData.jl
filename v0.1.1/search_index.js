var documenterSearchIndex = {"docs":
[{"location":"#ExpandNestedData.jl","page":"Home","title":"ExpandNestedData.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExpandNestedData.jl is a small package that can consume nested data structures like dictionaries of dictionaries or structs of structs and produce a normalized, Tables.jl-compliant NamedTuple. It can be used with JSON3.jl, XMLDict.jl, and other packages that parse file formats which are structured as denormalized data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depth = 4","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/mrufsvold/ExpandNestedData.jl\")","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExpandNestedData provides a single function expand to flatten out nested data. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExpandNestedData #hide\nusing JSON3\nusing DataFrames\n\nmessage = JSON3.read(\"\"\"\n    {\n        \"a\" : [\n            {\"b\" : 1, \"c\" : 2},\n            {\"b\" : 2},\n            {\"b\" : [3, 4], \"c\" : 1},\n            {\"b\" : []}\n        ],\n        \"d\" : 4\n    }\n    \"\"\"\n)\n\nexpand(message) |> DataFrame","category":"page"},{"location":"#Configuring-Options","page":"Home","title":"Configuring Options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While exapnd can produce a Table out of the box, it is often useful to configure some options in how it handles the normalization process. ExpandNestedData.jl offers two ways to set these configurations. You can set them globally with kwargs or exercise finer control with per-column configurations.","category":"page"},{"location":"#Keyword-Arguments","page":"Home","title":"Keyword Arguments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Parameter Description\nflatten_arrays::Bool When a leaf node is an array, should the values be flattened into separate rows or treated as a single value. Default: true\ndefault_value::Any When a certain key exists in one branch, but not another, what value should be used to fill missing. Default: missing\npool_arrays::Bool When collecting vectors for columns, choose whether to use PooledArrays instead of Base.Vector\ncolumn_names::Dict{Vector{Symbol}, Symbol} Provide a mapping of key/fieldname paths to replaced column names\ncolumn_style::T<:ExpandNestedData.ColumnStyle Chose returned column style from nested_columns or flat_columns. If nested, columnnames are ignored and a TypedTables.Table is returned for which the columns are nested in the same structure as the source data. Default: `flatcolumns`","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExpandNestedData #hide\nusing JSON3 #hide\nusing DataFrames #hide\n\nmessage = Dict( :a => [ Dict(:b => 1, :c => 2), Dict(:b => 2), Dict(:b => [3, 4], :c => 1), Dict(:b => []) ], :d => 4) #hide\n\nname_map = Dict([:a, :b] => :Column_B)\nexpand(message; flatten_arrays=true, default_value=\"no value\", pool_arrays=true, column_names=name_map) |> DataFrame","category":"page"},{"location":"#Using-ColumnDefintions","page":"Home","title":"Using ColumnDefintions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Instead of setting the configurations for the whole dataset, you can use a Vector{ColumnDefinition} to control how each column is handled. ColumnDefinition has the added benefit of allowing you to ignore certain fields from the input.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExpandNestedData #hide\nusing JSON3 #hide\nusing DataFrames #hide\n\nmessage = Dict( :a => [ Dict(:b => 1, :c => 2), Dict(:b => 2), Dict(:b => [3, 4], :c => 1), Dict(:b => []) ], :d => 4) #hide\n\ncolumn_defs = [\n    ColumnDefinition([:d]; column_name = :ColumnD),\n    ColumnDefinition([:a, :b]; flatten_arrays=true),\n    ColumnDefinition([:e, :f]; column_name = :MissingColumn, default_value=\"Missing branch\")\n]\n\nexpand(message, column_defs) |> DataFrame","category":"page"},{"location":"","page":"Home","title":"Home","text":"The only difference in the kwargs API here is that column_names is column_name and accepts a single Symbol.","category":"page"},{"location":"#ColumnStyles","page":"Home","title":"ColumnStyles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the examples above, we've used flat_columns style. However, we can also maintain the nesting heirarchy of the source data. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExpandNestedData #hide\nusing JSON3 #hide\nusing TypedTables\n\n\nmessage = Dict( :a => [ Dict(:b => 1, :c => 2), Dict(:b => 2), Dict(:b => [3, 4], :c => 1), Dict(:b => []) ], :d => 4) #hide\n\ntbl = expand(message; column_style = nested_columns)\ntbl.a.b[1] == 1 # true\n# `rows(tbl)` returns a nested NamedTuple \ntbl |> rows |> first","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExpandNestedData.expand(::Any)\nExpandNestedData.expand(::Any, ::Vector{ExpandNestedData.ColumnDefinition})\nExpandNestedData.ColumnDefinition","category":"page"},{"location":"#ExpandNestedData.expand-Tuple{Any}","page":"Home","title":"ExpandNestedData.expand","text":"expand(data; flatten_arrays = false, default_value = missing, pool_arrays = false, column_names=Dict{Vector{Symbol}, Symbol}())\n\nTake a nested data structure, data and convert it into a Table\n\nArgs\n\ndata: Any nested data structure (struct of structs or Dict of Dicts) or an array of such data structures\n\nKeyword Args\n\nflatten_arrays: When a leaf node is an array, should the values be flattened into separate rows or treated as a single value. Default: true\ndefault_value: When a certain key exists in one branch, but not another, what value should be used to fill missing. Default: missing\npool_arrays: When collecting vectors for columns, choose whether to use PooledArrays instead of Base.Vector. Default: false (use Vector)\ncolumn_names::Dict{Vector{Symbol}, Symbol}: Provide a mapping of key/fieldname paths to replaced column names\ncolumn_style: Chose returned column style from nested_columns or flat_columns. If nested, columnnames are ignored and   a TypedTables.Table is returned for which the columns are nested in the same structure as the source data. Default: `flatcolumns`\n\nReturns\n\n::NamedTuple: A Tables.jl compliant Tuple of Vectors\n\n\n\n\n\n","category":"method"},{"location":"#ExpandNestedData.expand-Tuple{Any, Vector{ColumnDefinition}}","page":"Home","title":"ExpandNestedData.expand","text":"expand(data, column_defs::Vector{ColumnDefinition})\n\nTake a nested data structure, data and convert it into a Table based on configurations passed for each column.\n\nArgs\n\ndata: Any nested data structure (struct of structs or Dict of Dicts) or an array of such data structures\ncolumn_defs::Vector{ColumnDefinition}: A ColumnDefinition for each column to be extracted from the data\ncolumn_style: Chose returned column style from nested_columns or flat_columns. If nested, columnnames are ignored and   a TypedTables.Table is returned for which the columns are nested in the same structure as the source data. Default: `flatcolumns`\n\nReturns\n\n::NamedTuple: A Tables.jl compliant Tuple of Vectors\n\n\n\n\n\n","category":"method"},{"location":"#ExpandNestedData.ColumnDefinition","page":"Home","title":"ExpandNestedData.ColumnDefinition","text":"ColumnDefinition provides a mechanism for specifying details for extracting data from a nested data source\n\n\n\n\n\n","category":"type"}]
}
